"""
This type stub file was generated by pyright.
"""

import abc
import sys
import warnings
from collections import deque
from functools import wraps

"""contextlib2 - backports and enhancements to the contextlib module"""
if sys.version_info[: 2] >= (3, 4):
    _abc_ABC = abc.ABC
else:
    _abc_ABC = abc.ABCMeta('ABC', (object, ), { '__slots__': () })
class AbstractContextManager(_abc_ABC):
    """An abstract base class for context managers."""
    def __enter__(self):
        """Return `self` upon entering the runtime context."""
        ...
    
    @abc.abstractmethod
    def __exit__(self, exc_type, exc_value, traceback):
        """Raise any exception triggered within the runtime context."""
        ...
    
    @classmethod
    def __subclasshook__(cls, C):
        """Check whether subclass is considered a subclass of this ABC."""
        ...
    


class ContextDecorator(object):
    """A base class or mixin that enables context managers to work as decorators."""
    def refresh_cm(self):
        """Returns the context manager used to actually wrap the call to the
        decorated function.

        The default implementation just returns *self*.

        Overriding this method allows otherwise one-shot context managers
        like _GeneratorContextManager to support use as decorators via
        implicit recreation.

        DEPRECATED: refresh_cm was never added to the standard library's
                    ContextDecorator API
        """
        ...
    
    def __call__(self, func):
        ...
    


class _GeneratorContextManager(ContextDecorator):
    """Helper for @contextmanager decorator."""
    def __init__(self, func, args, kwds) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, type, value, traceback):
        ...
    


def contextmanager(func):
    """@contextmanager decorator.

    Typical usage:

        @contextmanager
        def some_generator(<arguments>):
            <setup>
            try:
                yield <value>
            finally:
                <cleanup>

    This makes this:

        with some_generator(<arguments>) as <variable>:
            <body>

    equivalent to this:

        <setup>
        try:
            <variable> = <value>
            <body>
        finally:
            <cleanup>

    """
    ...

class closing(object):
    """Context to automatically close something at the end of a block.

    Code like this:

        with closing(<module>.open(<arguments>)) as f:
            <block>

    is equivalent to this:

        f = <module>.open(<arguments>)
        try:
            <block>
        finally:
            f.close()

    """
    def __init__(self, thing) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info):
        ...
    


class _RedirectStream(object):
    _stream = ...
    def __init__(self, new_target) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, exctype, excinst, exctb):
        ...
    


class redirect_stdout(_RedirectStream):
    """Context manager for temporarily redirecting stdout to another file.

        # How to send help() to stderr
        with redirect_stdout(sys.stderr):
            help(dir)

        # How to write help() to a file
        with open('help.txt', 'w') as f:
            with redirect_stdout(f):
                help(pow)
    """
    _stream = ...


class redirect_stderr(_RedirectStream):
    """Context manager for temporarily redirecting stderr to another file."""
    _stream = ...


class suppress(object):
    """Context manager to suppress specified exceptions

    After the exception is suppressed, execution proceeds with the next
    statement following the with statement.

         with suppress(FileNotFoundError):
             os.remove(somefile)
         # Execution still resumes here if the file was already removed
    """
    def __init__(self, *exceptions) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, exctype, excinst, exctb):
        ...
    


_HAVE_EXCEPTION_CHAINING = sys.version_info[0] >= 3
if _HAVE_EXCEPTION_CHAINING:
    ...
else:
    ...
class ExitStack(object):
    """Context manager for dynamic management of a stack of exit callbacks

    For example:

        with ExitStack() as stack:
            files = [stack.enter_context(open(fname)) for fname in filenames]
            # All opened files will automatically be closed at the end of
            # the with statement, even if attempts to open files later
            # in the list raise an exception

    """
    def __init__(self) -> None:
        ...
    
    def pop_all(self):
        """Preserve the context stack by transferring it to a new instance"""
        ...
    
    def push(self, exit):
        """Registers a callback with the standard __exit__ method signature

        Can suppress exceptions the same way __exit__ methods can.

        Also accepts any object with an __exit__ method (registering a call
        to the method instead of the object itself)
        """
        ...
    
    def callback(self, callback, *args, **kwds):
        """Registers an arbitrary callback and arguments.

        Cannot suppress exceptions.
        """
        ...
    
    def enter_context(self, cm):
        """Enters the supplied context manager

        If successful, also pushes its __exit__ method as a callback and
        returns the result of the __enter__ method.
        """
        ...
    
    def close(self):
        """Immediately unwind the context stack"""
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_details):
        ...
    


class ContextStack(ExitStack):
    """Backwards compatibility alias for ExitStack"""
    def __init__(self) -> None:
        ...
    
    def register_exit(self, callback):
        ...
    
    def register(self, callback, *args, **kwds):
        ...
    
    def preserve(self):
        ...
    


class nullcontext(AbstractContextManager):
    """Context manager that does no additional processing.
    Used as a stand-in for a normal context manager, when a particular
    block of code is only sometimes used with a normal context manager:
    cm = optional_cm if condition else nullcontext()
    with cm:
        # Perform operation, using optional_cm if condition is True
    """
    def __init__(self, enter_result=...) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *excinfo):
        ...
    


