"""
This type stub file was generated by pyright.
"""

import abc
import os
import sys
from __future__ import absolute_import, division, print_function, unicode_literals
from io import open

PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3
native_str = str
str = type('str')
def from_none(exc):
    """raise from_none(ValueError('a')) == raise ValueError('a') from None"""
    ...

def recursive_repr(fillvalue=...):
    'Decorator to make a repr function return fillvalue for a recursive call'
    ...

class _ChainMap(MutableMapping):
    ''' A ChainMap groups multiple dicts (or other mappings) together
    to create a single, updateable view.

    The underlying mappings are stored in a list.  That list is public and can
    accessed or updated using the *maps* attribute.  There is no other state.

    Lookups search the underlying mappings successively until a key is found.
    In contrast, writes, updates, and deletions only operate on the first
    mapping.

    '''
    def __init__(self, *maps) -> None:
        '''Initialize a ChainMap by setting *maps* to the given mappings.
        If no mappings are provided, a single empty dictionary is used.

        '''
        ...
    
    def __missing__(self, key):
        ...
    
    def __getitem__(self, key):
        ...
    
    def get(self, key, default=...):
        ...
    
    def __len__(self):
        ...
    
    def __iter__(self):
        ...
    
    def __contains__(self, key):
        ...
    
    @recursive_repr()
    def __repr__(self):
        ...
    
    @classmethod
    def fromkeys(cls, iterable, *args):
        'Create a ChainMap with a single dict created from the iterable.'
        ...
    
    def copy(self):
        """
        New ChainMap or subclass with a new copy of
        maps[0] and refs to maps[1:]
        """
        ...
    
    __copy__ = ...
    def new_child(self):
        'New ChainMap with a new dict followed by all previous maps.'
        ...
    
    @property
    def parents(self):
        'New ChainMap from maps[1:].'
        ...
    
    def __setitem__(self, key, value):
        ...
    
    def __delitem__(self, key):
        ...
    
    def popitem(self):
        """
        Remove and return an item pair from maps[0].
        Raise KeyError is maps[0] is empty.
        """
        ...
    
    def pop(self, key, *args):
        """
        Remove *key* from maps[0] and return its value.
        Raise KeyError if *key* not in maps[0].
        """
        ...
    
    def clear(self):
        'Clear maps[0], leaving maps[1:] intact.'
        ...
    


_ABC = getattr(abc, 'ABC', abc.ABCMeta(native_str('__ABC'), (object, ), dict(__metaclass__=abc.ABCMeta)))
class _PathLike(_ABC):
    """Abstract base class for implementing the file system path protocol."""
    @abc.abstractmethod
    def __fspath__(self):
        """Return the file system path representation of the object."""
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass):
        ...
    


PathLike = getattr(os, 'PathLike', _PathLike)
fspath = getattr(os, 'fspath', _fspath)
