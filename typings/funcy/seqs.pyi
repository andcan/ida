"""
This type stub file was generated by pyright.
"""

from itertools import chain
from .compat import PY2

def repeatedly(f, n=...):
    """Takes a function of no args, presumably with side effects,
       and returns an infinite (or length n) iterator of calls to it."""
    ...

def iterate(f, x):
    """Returns an infinite iterator of `x, f(x), f(f(x)), ...`"""
    ...

def take(n, seq):
    """Returns a list of first n items in the sequence,
       or all items if there are fewer than n."""
    ...

def drop(n, seq):
    """Skips first n items in the sequence, yields the rest."""
    ...

def first(seq):
    """Returns the first item in the sequence.
       Returns None if the sequence is empty."""
    ...

def second(seq):
    """Returns second item in the sequence.
       Returns None if there are less than two items in it."""
    ...

def nth(n, seq):
    """Returns nth item in the sequence or None if no such item exists."""
    ...

def last(seq):
    """Returns the last item in the sequence or iterator.
       Returns None if the sequence is empty."""
    ...

def rest(seq):
    """Skips first item in the sequence, yields the rest."""
    ...

def butlast(seq):
    """Iterates over all elements of the sequence but last."""
    ...

def ilen(seq):
    """Consumes an iterable not reading it into memory
       and returns the number of items."""
    ...

def lmap(f, *seqs):
    """An extended version of builtin map() returning a list.
       Derives a mapper from string, int, slice, dict or set."""
    ...

def lfilter(pred, seq):
    """An extended version of builtin filter() returning a list.
       Derives a predicate from string, int, slice, dict or set."""
    ...

def map(f, *seqs):
    """An extended version of builtin map().
       Derives a mapper from string, int, slice, dict or set."""
    ...

def filter(pred, seq):
    """An extended version of builtin filter().
       Derives a predicate from string, int, slice, dict or set."""
    ...

if PY2:
    def xmap(f, *seqs):
        ...
    
else:
    xmap = map
def lremove(pred, seq):
    """Creates a list if items passing given predicate."""
    ...

def remove(pred, seq):
    """Iterates items passing given predicate."""
    ...

def lkeep(f, seq=...):
    """Maps seq with f and keeps only truthy results.
       Simply lists truthy values in one argument version."""
    ...

def keep(f, seq=...):
    """Maps seq with f and iterates truthy results.
       Simply iterates truthy values in one argument version."""
    ...

def without(seq, *items):
    """Iterates over sequence skipping items."""
    ...

def lwithout(seq, *items):
    """Removes items from sequence, preserves order."""
    ...

def lconcat(*seqs):
    """Concatenates several sequences."""
    ...

concat = chain
def lcat(seqs):
    """Concatenates the sequence of sequences."""
    ...

cat = chain.from_iterable
def flatten(seq, follow=...):
    """Flattens arbitrary nested sequence.
       Unpacks an item if follow(item) is truthy."""
    ...

def lflatten(seq, follow=...):
    """Iterates over arbitrary nested sequence.
       Dives into when follow(item) is truthy."""
    ...

def lmapcat(f, *seqs):
    """Maps given sequence(s) and concatenates the results."""
    ...

def mapcat(f, *seqs):
    """Maps given sequence(s) and chains the results."""
    ...

def interleave(*seqs):
    """Yields first item of each sequence, then second one and so on."""
    ...

def interpose(sep, seq):
    """Yields items of the sequence alternating with sep."""
    ...

def takewhile(pred, seq=...):
    """Yields sequence items until first predicate fail.
       Stops on first falsy value in one argument version."""
    ...

def dropwhile(pred, seq=...):
    """Skips the start of the sequence passing pred (or just truthy),
       then iterates over the rest."""
    ...

def ldistinct(seq, key=...):
    """Removes duplicates from sequences, preserves order."""
    ...

def distinct(seq, key=...):
    """Iterates over sequence skipping duplicates"""
    ...

def split(pred, seq):
    """Lazily splits items which pass the predicate from the ones that don't.
       Returns a pair (passed, failed) of respective iterators."""
    ...

def lsplit(pred, seq):
    """Splits items which pass the predicate from the ones that don't.
       Returns a pair (passed, failed) of respective lists."""
    ...

def split_at(n, seq):
    """Lazily splits the sequence at given position,
       returning a pair of iterators over its start and tail."""
    ...

def lsplit_at(n, seq):
    """Splits the sequence at given position,
       returning a tuple of its start and tail."""
    ...

def split_by(pred, seq):
    """Lazily splits the start of the sequence,
       consisting of items passing pred, from the rest of it."""
    ...

def lsplit_by(pred, seq):
    """Splits the start of the sequence,
       consisting of items passing pred, from the rest of it."""
    ...

def group_by(f, seq):
    """Groups given sequence items into a mapping f(item) -> [item, ...]."""
    ...

def group_by_keys(get_keys, seq):
    """Groups items having multiple keys into a mapping key -> [item, ...].
       Item might be repeated under several keys."""
    ...

def group_values(seq):
    """Takes a sequence of (key, value) pairs and groups values by keys."""
    ...

def count_by(f, seq):
    """Counts numbers of occurrences of values of f()
       on elements of given sequence."""
    ...

def count_reps(seq):
    """Counts number occurrences of each value in the sequence."""
    ...

def partition(n, step, seq=...):
    """Lazily partitions seq into parts of length n.
       Skips step items between parts if passed. Non-fitting tail is ignored."""
    ...

def lpartition(n, step, seq=...):
    """Partitions seq into parts of length n.
       Skips step items between parts if passed. Non-fitting tail is ignored."""
    ...

def chunks(n, step, seq=...):
    """Lazily chunks seq into parts of length n or less.
       Skips step items between parts if passed."""
    ...

def lchunks(n, step, seq=...):
    """Chunks seq into parts of length n or less.
       Skips step items between parts if passed."""
    ...

def partition_by(f, seq):
    """Lazily partition seq into continuous chunks with constant value of f."""
    ...

def lpartition_by(f, seq):
    """Partition seq into continuous chunks with constant value of f."""
    ...

def with_prev(seq, fill=...):
    """Yields each item paired with its preceding: (item, prev)."""
    ...

def with_next(seq, fill=...):
    """Yields each item paired with its following: (item, next)."""
    ...

def pairwise(seq):
    """Yields all pairs of neighboring items in seq."""
    ...

def lreductions(f, seq, acc=...):
    """Lists intermediate reductions of seq by f."""
    ...

def sums(seq, acc=...):
    """Yields partial sums of seq."""
    ...

def lsums(seq, acc=...):
    """Lists partial sums of seq."""
    ...

