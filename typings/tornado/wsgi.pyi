"""
This type stub file was generated by pyright.
"""

from tornado import httputil, web
from tornado.util import PY3, unicode_type

"""WSGI support for the Tornado web framework.

WSGI is the Python standard for web servers, and allows for interoperability
between Tornado and other Python web frameworks and servers.  This module
provides WSGI support in two ways:

* `WSGIAdapter` converts a `tornado.web.Application` to the WSGI application
  interface.  This is useful for running a Tornado app on another
  HTTP server, such as Google App Engine.  See the `WSGIAdapter` class
  documentation for limitations that apply.
* `WSGIContainer` lets you run other WSGI applications and frameworks on the
  Tornado HTTP server.  For example, with this class you can mix Django
  and Tornado handlers in a single server.
"""
if PY3:
    ...
else:
    ...
if str is unicode_type:
    def to_wsgi_str(s):
        ...
    
    def from_wsgi_str(s):
        ...
    
else:
    def to_wsgi_str(s):
        ...
    
    def from_wsgi_str(s):
        ...
    
class WSGIApplication(web.Application):
    """A WSGI equivalent of `tornado.web.Application`.

    .. deprecated:: 4.0

       Use a regular `.Application` and wrap it in `WSGIAdapter` instead.
       This class will be removed in Tornado 6.0.
    """
    def __call__(self, environ, start_response):
        ...
    


class _WSGIConnection(httputil.HTTPConnection):
    def __init__(self, method, start_response, context) -> None:
        ...
    
    def set_close_callback(self, callback):
        ...
    
    def write_headers(self, start_line, headers, chunk=..., callback=...):
        ...
    
    def write(self, chunk, callback=...):
        ...
    
    def finish(self):
        ...
    


class _WSGIRequestContext(object):
    def __init__(self, remote_ip, protocol) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class WSGIAdapter(object):
    """Converts a `tornado.web.Application` instance into a WSGI application.

    Example usage::

        import tornado.web
        import tornado.wsgi
        import wsgiref.simple_server

        class MainHandler(tornado.web.RequestHandler):
            def get(self):
                self.write("Hello, world")

        if __name__ == "__main__":
            application = tornado.web.Application([
                (r"/", MainHandler),
            ])
            wsgi_app = tornado.wsgi.WSGIAdapter(application)
            server = wsgiref.simple_server.make_server('', 8888, wsgi_app)
            server.serve_forever()

    See the `appengine demo
    <https://github.com/tornadoweb/tornado/tree/stable/demos/appengine>`_
    for an example of using this module to run a Tornado app on Google
    App Engine.

    In WSGI mode asynchronous methods are not supported.  This means
    that it is not possible to use `.AsyncHTTPClient`, or the
    `tornado.auth` or `tornado.websocket` modules.

    In multithreaded WSGI servers on Python 3, it may be necessary to
    permit `asyncio` to create event loops on any thread. Run the
    following at startup (typically import time for WSGI
    applications)::

        import asyncio
        from tornado.platform.asyncio import AnyThreadEventLoopPolicy
        asyncio.set_event_loop_policy(AnyThreadEventLoopPolicy())

    .. versionadded:: 4.0

    .. deprecated:: 5.1

       This class is deprecated and will be removed in Tornado 6.0.
       Use Tornado's `.HTTPServer` instead of a WSGI container.
    """
    def __init__(self, application) -> None:
        ...
    
    def __call__(self, environ, start_response):
        ...
    


class WSGIContainer(object):
    r"""Makes a WSGI-compatible function runnable on Tornado's HTTP server.

    .. warning::

       WSGI is a *synchronous* interface, while Tornado's concurrency model
       is based on single-threaded asynchronous execution.  This means that
       running a WSGI app with Tornado's `WSGIContainer` is *less scalable*
       than running the same app in a multi-threaded WSGI server like
       ``gunicorn`` or ``uwsgi``.  Use `WSGIContainer` only when there are
       benefits to combining Tornado and WSGI in the same process that
       outweigh the reduced scalability.

    Wrap a WSGI function in a `WSGIContainer` and pass it to `.HTTPServer` to
    run it. For example::

        def simple_app(environ, start_response):
            status = "200 OK"
            response_headers = [("Content-type", "text/plain")]
            start_response(status, response_headers)
            return ["Hello world!\n"]

        container = tornado.wsgi.WSGIContainer(simple_app)
        http_server = tornado.httpserver.HTTPServer(container)
        http_server.listen(8888)
        tornado.ioloop.IOLoop.current().start()

    This class is intended to let other frameworks (Django, web.py, etc)
    run on the Tornado HTTP server and I/O loop.

    The `tornado.web.FallbackHandler` class is often useful for mixing
    Tornado and WSGI apps in the same server.  See
    https://github.com/bdarnell/django-tornado-demo for a complete example.
    """
    def __init__(self, wsgi_application) -> None:
        ...
    
    def __call__(self, request):
        ...
    
    @staticmethod
    def environ(request):
        """Converts a `tornado.httputil.HTTPServerRequest` to a WSGI environment.
        """
        ...
    


HTTPRequest = httputil.HTTPServerRequest
